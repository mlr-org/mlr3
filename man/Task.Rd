% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Task.R
\name{Task}
\alias{Task}
\title{Abstract learning task}
\description{
This is the abstract base class for task objects like \link{TaskClassif} and \link{TaskRegr}.
}
\section{Usage}{
\preformatted{t = Task$new(id, backend)

t$id
t$backend
t$row_roles
t$col_info
t$set_row_role(rows, new_roles, exclusive = TRUE)
t$set_col_role(cols, new_roles, exclusive = TRUE)
t$measures
t$data(rows = NULL, cols = NULL)
t$head(n = 6)
t$levels(col)
t$row_ids(subset = NULL)
t$features_names
t$target_names
t$nrow
t$ncol
t$feature_types
t$formula
t$hash

t$filter(rows)
t$select(cols)
t$rbind(data)
t$cbind(data)
}
}

\section{Arguments}{

\itemize{
\item \code{id} (\code{string}):
Name of the task.
\item \code{backend} (\link{DataBackend}):
\link{DataBackend} which stores the data.
\item \code{data} (\link[base:data.frame]{base::data.frame}):
New data to rbind/cbind to the task.
\item \code{rows} (\code{vector}):
Vector of row ids specifying rows from the \link{DataBackend} using its primary key.
Can be \code{character()} or \code{integer}, depending on the \link{DataBackend}.
\item \code{cols} (\code{character()}):
Character vector to specify columns from the \link{DataBackend}.
\item \code{col} (\code{character(1)}):
Character vector to specify a single column from the \link{DataBackend}.
\item \code{n} (\code{integer(1)}):
Number of rows to retrieve from the \link{DataBackend}.
\item \code{new_roles} (\code{character(1)}):
New roles to assign for specified rows/columns.
\item \code{exclusive} (\code{logical(1)}):
If \code{TRUE}, the cols/rows will be removed from all roles except \code{new_roles}.
\item \code{subset} (\code{vector}):
Subset of row ids to subset rows from the \link{DataBackend} using its primary key.
}
}

\section{Details}{

\code{$new()} initializes a new object of class \link{Task}.

\code{$id} (\code{character(1)}) stores the name of the task.

\code{$backend()} (\link{DataBackend}) stores the \link{DataBackend} of the task.

\code{$row_roles} (\code{list}).
Stores the row ids of \link{DataBackend} in vectors of row roles:
\itemize{
\item \code{"use"}: Use in training.
\item \code{"validation"}: Do not use in training, this are (possibly unlabeled) observations
which are held back unless explicitly addressed.
To alter the role, use \code{set_row_role()}.
}

\code{$col_info} (\code{data.table}) with columns \code{id}, \code{role} and \code{type}.
Stores column names of \link{DataBackend} in column \code{id}. Each column (feature)
can have a specific mutually exclusive role in the learning task:
\itemize{
\item \code{"feature"}: Regular feature.
\item \code{"target"}: Column with target labels.
\item \code{"ignore"}: Do not these features at all.
\item \code{"primary_key"}: Name of the primary id column used in \link{DataBackend}.
Column \code{type} stores the storage type of the variable, e.g. \code{integer}, \code{numeric} or \code{character}.
To alter the role, use \code{set_col_role()}.
}

\code{$set_row_role()} overwrites the role for specified rows, referenced by row id.

\code{$set_col_role()} overwrites the role for specified columns.

\code{$measures} is a list of \link{Measure} (performance measures) to use in this task.

\code{$data()} is used to retrieve data from the backend as \code{data.table}.
Rows are subsetted to only contain observations with \code{role == "use"}.
Columns are filtered to only contain features with \code{role \%in\% c("target", "feature")}.
If invalid \code{rows} or \code{cols} are specified, an exception is raised.

\code{$head()} can be used to peek into the first \code{n} observations with \code{role == "use"}.

\code{$levels()} queries the distinct levels of the column \code{col}. Only works for \code{character} and \code{factor} columns.
This function ignores the row roles, so you get all levels found in the \link{DataBackend}.

\code{$row_ids()} returns a (subset of) row ids used in the task, i.e. subsetted to observations with \code{role == "use"}.

\code{$feature_names} returns a \code{character} vector of all feature names with \code{role == "feature"}.

\code{$target_names} returns a \code{character} vector of all feature names with \code{role == "target"}.

\code{$nrow} provides the total number of rows with \code{role == "use"}.

\code{$ncol} provides the total number of cols with \code{role \%in\% c("target", "feature")}.

\code{$feature_types} gives a \code{data.table} with columns \code{id} and \code{type} where \code{id} are the column names of "active" features of the task and \code{type} is the storage type.

\code{$formula} constructs a \link[stats:formula]{stats::formula}, e.g. \code{[target] ~ [feature_1] + [feature_2] + ... + [feature_k]}.

\code{$filter()} reduces the task, subsetting it to only the rows specified.

\code{$select()} reduces the task, subsetting it to only the columns specified.

\code{$rbind()} extends the task with additional rows.

\code{$cbind()} extends the task with additional columns.

\code{$hash} stores a checksum (\code{character(1)}) calculated on the \code{id}, \code{row_roles} and \code{col_info}.
}

\examples{
b = DataBackendDataTable$new(iris)
task = Task$new("iris", b)
task$nrow
task$ncol
task$head()
task$formula

# Remove "Petal.Length"
task$set_col_role("Petal.Length", character(0L))
task$formula
}
\seealso{
Other Task: \code{\link{TaskClassif}},
  \code{\link{TaskRegr}}, \code{\link{TaskSupervised}},
  \code{\link{mlr_tasks}}
}
\concept{Task}
\keyword{internal}

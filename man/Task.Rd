% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Task.R
\name{Task}
\alias{Task}
\title{Supervised or Unsupervised Tasks}
\format{\link{R6Class} object.}
\description{
This is the abstract base class for task objects like \link{TaskClassif} and \link{TaskRegr}.
}
\section{Usage}{
\preformatted{# Construction
t = Task$new(id, backend, task_type)

# Members
t$backend
t$col_info
t$col_roles
t$features_names
t$feature_types
t$formula
t$groups
t$hash
t$id
t$measures
t$ncol
t$nrow
t$properties
t$row_ids
t$row_roles
t$target_names
t$task_type

# Methods: Accessors
t$data(rows = NULL, cols = NULL)
t$head(n = 6)
t$levels(col)
t$set_col_role(cols, new_roles, exclusive = TRUE)
t$set_row_role(rows, new_roles, exclusive = TRUE)

# Methods: Mutators
t$cbind(data)
t$filter(rows)
t$rbind(data)
t$select(cols)
}
}

\section{Arguments}{

\itemize{
\item \code{id} (\code{character(1)}):
Name of the task.
\item \code{backend} (\link{DataBackend}):
\link{DataBackend} which stores the data.
\item \code{task_type} (\code{character(1)}):
Task type. Set via class which inherits from \link{Task}.
\item \code{rows} (\code{integer()} | \code{character()}):
Vector of row ids specifying rows from the \link{DataBackend} using its primary key.
Can be \code{character()} or \code{integer}, depending on the \link{DataBackend}.
\item \code{cols} (\code{character()}):
Character vector to specify columns from the \link{DataBackend}.
\item \code{n} (\code{integer(1)}):
Number of rows to retrieve from the \link{DataBackend}.
\item \code{col} (\code{character(1)}):
Character vector to specify a single column from the \link{DataBackend}.
\item \code{new_roles} (\code{character(1)}):
New roles to assign for specified rows/columns.
\item \code{exclusive} (\code{logical(1)}):
If \code{TRUE}, the cols/rows will be removed from all roles except \code{new_roles}.
\item \code{data} (\code{\link[=data.frame]{data.frame()}}):
New data to rbind/cbind to the task.
}
}

\section{Details}{

\itemize{
\item \code{$backend} (\link{DataBackend}) stores the \link{DataBackend} of the task.
\item \code{$cbind} extends the task with additional columns.
The row ids must be provided as column in \code{data} (with column name matching the primary key name of the \link{DataBackend}).
\item \code{$col_info} (\code{\link[=data.table]{data.table()}}) with columns \code{id}, \code{type} and \code{levels}.
Stores column names of \link{DataBackend} in column \code{id}.
Column \code{type} stores the storage type of the variables, e.g. \code{integer}, \code{numeric} or \code{character}.
Column \code{levels} stores the levels for factor and character variables.
\item \code{$col_roles} (\code{list}). Each column (feature)
can have a specific mutually exclusive role in the learning task:
\itemize{
\item \code{"feature"}: Regular feature.
\item \code{"target"}: Column with target labels.
\item \code{"order"}: Returned data is ordered by these column(s).
\item \code{"groups"}: During resampling, observations with the same value of the variable with role "groups"
are marked as "belonging together". They will be exclusively assigned to be either in the training set
or the test set.
Returns a (\code{\link[=data.table]{data.table()}}) with two columns: first column are rows ids, second column are the group labels.
\item \code{"weights"}: Observation weights. (\code{\link[=data.table]{data.table()}}) with two columns: first column are the row ids,
second column are the observation weights.
To alter the role, use \code{$set_col_role()}
}
\item \code{$data} is used to retrieve data from the backend as \code{\link[=data.table]{data.table()}}.
Rows are subsetted to only contain observations with \code{role == "use"}.
Columns are filtered to only contain features with \code{role \%in\% c("target", "feature")}.
If invalid \code{rows} or \code{cols} are specified, an exception is raised.
\item \code{$feature_names} (\code{character()}) returns all column names with \code{role == "feature"}.
\item \code{$feature_types} (\code{\link[=data.table]{data.table()}}) returns a table with columns \code{id} and \code{type} where \code{id} are the column names of "active"
features of the task and \code{type} is the storage type.
\item \code{$filter} reduces the task, subsetting it to only the rows specified.
\item \code{$formula} constructs a \link[stats:formula]{stats::formula}, e.g. \code{[target] ~ [feature_1] + [feature_2] + ... + [feature_k]}.
\item \code{$groups} returns a (\code{\link[=data.table]{data.table()}}) with two columns: the row ids and the grouping / blocking information.
\item \code{$hash} (\code{character(1)}) stores a checksum calculated on the \code{id}, \code{row_roles} and \code{col_roles}.
\item \code{$head} (\code{\link[=data.table]{data.table()}}) can be used to peek into the first \code{n} observations with \code{role == "use"}.
\item \code{$id} (\code{character(1)}) stores the name of the task.
\item \code{$measures} (\code{list} of \link{Measure}) stores the default measures for this task.
\item \code{$ncol} (\code{integer(1)}) provides the total number of cols with \code{role \%in\% c("target", "feature")}.
\item \code{$nrow} (\code{integer(1)}) provides the total number of rows with \code{role == "use"}.
\item \code{$row_ids} (\code{\link[=data.table]{data.table()}}) returns the active row ids used in the backend, i.e. subsetted to observations with \code{role == "use"}.
The column names of the returned \code{\link[=data.table]{data.table()}} equals the primary key column in the \link{DataBackend}.
\item \code{$row_roles} (\code{list}). Stores the row ids of \link{DataBackend} in vectors of row roles:
\itemize{
\item \code{"use"}: Use in training.
\item \code{"validation"}: Do not use in training, this are (possibly unlabeled) observations
which are held back unless explicitly addressed.
To alter the role, use \code{set_row_role()}.
}
\item \code{$target_names} (\code{character()}) returns all column names with \code{role == "target"}.
\item \code{$new()} initializes a new object of class \link{Task}.
\item \code{$levels()} (\code{character()}) queries the distinct levels of the column \code{col}. Only works for \code{character} and \code{factor} columns.
This function ignores the row roles, so you get all levels found in the \link{DataBackend}.
\item \code{$rbind()} extends the task with additional rows.
\item \code{$select()} reduces the task, subsetting it to only the columns specified.
\item \code{$set_col_role()} sets the role for specified columns, referenced by name.
If \code{exclusive} is \code{TRUE}, the referenced columns will be removed from all other roles.
\item \code{$set_row_role()} sets the role for specified rows, referenced by row id.
If \code{exclusive} is \code{TRUE}, the referenced rows will be removed from all other roles.
}
}

\section{Task mutators}{

The methods \code{filter()}, \code{select()}, \code{rbind()}, and \code{cbind()} change the task in-place,
but without modifying the \link{DataBackend}.
\code{filter()} and \code{select()} just reduce the set of active rows or columns, providing a different view on the data.
\code{rbind()} and \code{cbind()} first create a new \link{DataBackendDataTable} from the provided new data, and then
merge both backends into an abstract \link{DataBackend} which combines the results on-demand.
}

\examples{
b = as_data_backend(iris)
task = Task$new("iris", task_type = "classif", backend = b)

task$nrow
task$ncol
task$head()
task$feature_names
task$formula

# Remove "Petal.Length"
task$set_col_role("Petal.Length", character(0L))

# Remove "Petal.Width", alternative way
task$select(setdiff(task$feature_names, "Petal.Width"))

task$feature_names

# Add new column "foo"
task$cbind(cbind(data.frame(foo = 1:150), task$row_ids))
}
\seealso{
Other Task: \code{\link{TaskClassif}},
  \code{\link{TaskRegr}}, \code{\link{TaskSupervised}},
  \code{\link{mlr_tasks}}
}
\concept{Task}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/marshal.R
\name{marshalling}
\alias{marshalling}
\alias{learner_unmarshal}
\alias{learner_marshal}
\alias{learner_marshalled}
\alias{marshal_model}
\alias{unmarshal_model}
\alias{marshalled_model}
\title{(Un)marshal a Learner}
\usage{
learner_unmarshal(learner)

learner_marshal(learner)

learner_marshalled(learner)

marshal_model(model, ...)

unmarshal_model(model, ...)

marshalled_model(model)
}
\arguments{
\item{learner}{\code{\link{Learner}}\cr
The learner to marshal.}
}
\description{
Marshalling is the process of processing the model of a trained \code{\link{Learner}} so it an be successfully serialized and
deserialized. The naming is inspired from package \href{https://github.com/HenrikBengtsson/marshal}{marshall} and we
plan to fully migrate to this package once it is on CRAN.
The supported implementation until then should therfore be considered as a temporary solution and is likely
to change in the future.

The central functions (and the only methods that are used by \code{mlr3} internally) are:
\itemize{
\item the S3 generic \code{marshal_model(model, ...)}.
Which takes in a model and returns it in marshalled form.
The suffix \code{"_marshalled"} should be added to the class of the returned object and the root class must
be set to \code{"marshalled"}.
\item the S3 generic \code{unmarshal_model(model, ...)}.
Which takes in a model and returns it in unmarshalled form.
The returned object must not inherit from class \code{"marshalled"}.
\item the function \code{marshalled_model(model)}, which returns \code{TRUE} if the model inherits from class \code{"marshalled"}
and \code{FALSE} otherwise.
}

In order to implement marshalling for a Learner, you only need to overload the \code{marshal_model} and \code{unmarshal_model}
methods and tag the learner with the \code{"marshal"} property accordingly.

To make marshalling accessible in an R6-manner, you should also add the public methods \verb{$marshal()}, \verb{$unmarshal()}
and the active binding \verb{$marshalled}.
To make this as convenient as possible, the functions \code{learner_marshal(learner)}, \code{learner_unmarshal(learner)}
and \code{learner_marshalled(learner)} are provided and can be called from within the public methods.
All three functions throw an error if the learner is not trained and otherwise call
\code{marshal_model()}, \code{unmarshal_model()} or \code{marshalled_model()} on the learner's model.

You can verify whether you have correctly implemented marshalling by using the internal test helper
\code{expect_marshallable_learner()}. This is also run by \code{expect_learner()} if a task is provided.

For a concrete example on how to implement marshalling, see \code{\link{LearnerClassifLily}}.
}
\keyword{internal}

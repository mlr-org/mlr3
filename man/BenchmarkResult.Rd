% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BenchmarkResult.R
\docType{data}
\name{BenchmarkResult}
\alias{BenchmarkResult}
\title{Container for Results of \code{benchmark()}}
\format{\link[R6:R6Class]{R6::R6Class} object.}
\description{
This is the result container object returned by \code{\link[=benchmark]{benchmark()}}.

Note that all stored objects are accessed by reference.
Do not modify any object without cloning it first.
}
\section{Construction}{
\preformatted{bmr = BenchmarkResult$new(data)
}
\itemize{
\item \code{data} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table with the data of one resampling iteration per row.
}
}

\section{Fields}{

\itemize{
\item \code{data} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Internal data storage.
\item \code{tasks} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table of used tasks with three columns:
"task_hash" (\code{character(1)}), "task_id" (\code{character(1)}) and "task" (\link{Task}).
\item \code{learners} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table of used learners with three columns:
"learner_hash" (\code{character(1)}), "learner_id" (\code{character(1)}) and "learner" (\link{Learner}).
\item \code{resamplings} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table of used resamplings with three columns:
"resampling_hash" (\code{character(1)}), "resampling_id" (\code{character(1)}) and "resampling" (\link{Resampling}).
}
}

\section{Methods}{

\itemize{
\item \code{aggregate(measures = NULL, ids = TRUE, params = FALSE)}\cr
(\code{logical(1)}, \code{logical(1)}, \code{logical(1)}) -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Returns a result table where experiments are aggregated per \link{ResampleResult}.
Arguments control the number of additional columns:
\itemize{
\item \code{ids} :: \code{logical(1)}\cr
Return object ids as columns in the result \code{data.table()}.
\item \code{params} :: \code{logical(1)}\cr
Return learner hyperparameter values as list column \code{params} in the result \code{data.table()}.
}
\item \code{performance(measures = NULL, ids = TRUE)}\cr
\code{list()} of \link{Measure} -> \code{data.table()}\cr
Returns a table with one row for each resampling iteration, including all involved objects.
Additionally calculates the provided performance measures and binds the performance as extra column.
If no measure is provided, defaults to the measure defined in \link[=mlr_reflections]{mlr_reflections$default_measures}
(\link{mlr_measures_classif.ce} for classification and \link{mlr_measures_regr.mse} for regression).
If \code{ids} is \code{TRUE}, character column of id names are added to the table for convenient filtering.
\item \code{combine(bmr)}\cr
\link{BenchmarkResult} -> \code{self}\cr
Fuses a second \link{BenchmarkResult} into itself.
}
}

\section{S3 Methods}{

\itemize{
\item \code{as.data.table(bmr)}\cr
\link{BenchmarkResult} -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Returns a copy of the internal data.
}
}

\examples{
set.seed(123)
tasks = mlr_tasks$mget(c("sonar", "spam"))
learners = mlr_learners$mget(c("classif.featureless", "classif.rpart"), predict_type = "prob")
resamplings = mlr_resamplings$get("cv3")
design = expand_grid(tasks = tasks, learners = learners, resamplings = resamplings)
print(design)

bmr = benchmark(design)
print(bmr)

bmr$tasks
bmr$learners

# first 5 individual resamplings
head(as.data.table(bmr, measures = c("classif.acc", "classif.auc")), 5)

# aggregate results
bmr$aggregate()

# aggregate results with hyperparameters as separate columns
mlr3misc::unnest(bmr$aggregate(params = TRUE), "params")

# extract resample result for classif.rpart
rr = bmr$aggregate()[learner_id == "classif.rpart", resample_result][[1]]
print(rr)

# access the confusion matrix of the first resampling iteration
rr$data$prediction[[1]]$confusion
}
\keyword{datasets}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BenchmarkResult.R
\docType{data}
\name{BenchmarkResult}
\alias{BenchmarkResult}
\title{Container for Results of \code{benchmark()}}
\format{\link[R6:R6Class]{R6::R6Class} object.}
\description{
This is the result container object returned by \code{\link[=benchmark]{benchmark()}}.

Note that all stored objects are accessed by reference.
Do not modify any object without cloning it first.
}
\section{Construction}{
\preformatted{bmr = BenchmarkResult$new(data)
}
\itemize{
\item \code{data} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table with the data of one resampling iteration per row.
}
}

\section{Fields}{

\itemize{
\item \code{data} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Internal data storage.
\item \code{tasks} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table of used tasks with three columns:
"task_hash" (\code{character(1)}), "task_id" (\code{character(1)}) and "task" (\link{Task}).
\item \code{learners} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table of used learners with three columns:
"learner_hash" (\code{character(1)}), "learner_id" (\code{character(1)}) and "learner" (\link{Learner}).
\item \code{resamplings} :: \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Table of used resamplings with three columns:
"resampling_hash" (\code{character(1)}), "resampling_id" (\code{character(1)}) and "resampling" (\link{Resampling}).
}
}

\section{Methods}{

\itemize{
\item \code{aggregated(objects = TRUE, ids = TRUE, params = FALSE)}\cr
(\code{logical(1)}, \code{logical(1)}, \code{logical(1)}) -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Returns a result table where experiments are aggregated per \link{ResampleResult}.
Arguments control the number of additional columns:
\itemize{
\item \code{objects} :: \code{logical(1)}\cr
Return objects as columns in the result \code{data.table()}.
\item \code{ids} :: \code{logical(1)}\cr
Return object ids as columns in the result \code{data.table()}.
\item \code{params} :: \code{logical(1)}\cr
Return learner hyperparameter values as list column \code{params} in the result \code{data.table()}.
}
\item \code{combine(bmr)}\cr
\link{BenchmarkResult} -> \code{self}\cr
Fuses a second \link{BenchmarkResult} into itself.
}
}

\section{S3 Methods}{

\itemize{
\item \code{as.data.table(bmr, measures = NULL)}\cr
\link{BenchmarkResult} -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Converts the data to a \code{data.table()}, with performance of provided measures as separate columns.
If no measure is provided, defaults to the measure defined in \link[=mlr_reflections]{mlr_reflections$default_measures}
(\link{mlr_measures_classif.ce} for classification and \link{mlr_measures_regr.mse} for regression).
}
}

\examples{
set.seed(123)
tasks = mlr_tasks$mget(c("sonar", "spam"))
learners = mlr_learners$mget(c("classif.featureless", "classif.rpart"), predict_type = "prob")
resamplings = mlr_resamplings$get("cv3")
design = expand_grid(tasks = tasks, learners = learners, resamplings = resamplings)
print(design)

bmr = benchmark(design)
print(bmr)

bmr$tasks
bmr$learners

# first 5 individual resamplings
head(as.data.table(bmr, measures = c("classif.acc", "classif.auc")), 5)

# aggregated results
bmr$aggregated()

# aggregated results with hyperparameters as separate columns
mlr3misc::unnest(bmr$aggregated(params = TRUE), "params")

# extract resample result for classif.rpart
rr = bmr$aggregated()[learner_id == "classif.rpart", resample_result][[1]]
print(rr)

# access the confusion matrix of the first resampling iteration
rr$data$prediction[[1]]$confusion
}
\keyword{datasets}

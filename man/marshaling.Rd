% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/marshal.R
\name{marshaling}
\alias{marshaling}
\alias{learner_unmarshal}
\alias{learner_marshal}
\alias{learner_marshaled}
\alias{marshal_model}
\alias{unmarshal_model}
\alias{is_marshaled_model}
\title{(Un)marshal a Learner}
\usage{
learner_unmarshal(.learner, ...)

learner_marshal(.learner, ...)

learner_marshaled(.learner)

marshal_model(model, inplace = FALSE, ...)

unmarshal_model(model, inplace = FALSE, ...)

is_marshaled_model(model)
}
\arguments{
\item{.learner}{\code{\link{Learner}}\cr
The learner.}

\item{...}{(any)\cr
Additional parameters, currently unused.}
}
\description{
Marshaling is the process of processing the model of a trained \code{\link{Learner}} so it an be successfully serialized and
deserialized. The naming is inspired by the \href{https://github.com/HenrikBengtsson/marshal}{marshal package} and we
plan to fully migrate to this package once it is on CRAN.
The supported implementation until then should therfore be considered as a temporary solution and is likely
to change in the future.

The central functions (and the only methods that are used by \code{mlr3} internally) are:
\itemize{
\item the S3 generic \code{marshal_model(model, inplace, ...)}.
Which takes in a model and returns it in marshaled form.
The marshaled object should be a list with named elements \code{marshaled} and \code{packages}, where the former contains
the marshaled object, and the latter the packages required to unmarshal it.
This list should have the classes of the original object with the suffix \code{"_marshaled"} appended and the
root class should be set to \code{"marshaled"}.
\item the S3 generic \verb{unmarshal_model(model, inplace ...)}.
Which takes in the marshaled model and returns it in unmarshaled form.
The generic takes care that the packages specified during \code{"marshal"} are loaded, and errs if they are not.
The returned object must not inherit from class \code{"marshaled"}.
\item the function \verb{is_ marshaled_model(model)}, which returns \code{TRUE} if the model inherits from class \code{"marshaled"}
and \code{FALSE} otherwise.
}

The contract of these generics is:
\itemize{
\item \code{unmarshal_model(marshal_model(x))} returns \code{x} as is.
\item \code{unmarshal_model(x)} can be serialized and de-serialzed without loss of information.
\item If \code{is_marshaled_model(x)} is \code{TRUE}, this means that \code{x} is in marshaled form.
Note that it is not guarateed that \code{is_marshaled_model(marshal_model(x))} returns \code{TRUE}.
This is because the default \code{marshal_model(x)} returns \code{x} as-is.
\item The \code{inplace} argument determines whether in-place marshaling should be performed.
This is especially relevant in the context of references semantics.
If \code{inplace} is \code{FALSE}, the marshaled model should not share references with the original model.
If \code{inplace} is \code{TRUE} this is not necessary and the original object can be modified in-place.
}
}
\section{Implementing Marshaling}{


In order to implement marshaling for a Learner, you only need to overload the \code{marshal_model} and \code{unmarshal_model}
methods and tag the learner with the \code{"marshal"} property accordingly.

To make marshaling accessible in an R6-manner, you should also add the public methods \verb{$marshal()}, \verb{$unmarshal()}
and the active binding \verb{$marshaled}.
To make this as convenient as possible, the functions \code{learner_marshal(learner)}, \code{learner_unmarshal(learner)}
and \code{learner_marshaled(learner)} are provided and can be called from within the public methods.
All three functions throw an error if the learner is not trained and otherwise call
\code{marshal_model()}, \code{unmarshal_model()} or \code{is_marshaled_model()} on the learner's model.

You can verify whether you have correctly implemented marshaling by using the internal test helper
\code{expect_marshalable_learner()}. This is also run by \code{expect_learner()} if a task is provided.

For a concrete example on how to implement marshaling, see \code{\link{LearnerClassifDebug}}.
}

\keyword{internal}

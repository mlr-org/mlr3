% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/marshal.R
\name{marshaling}
\alias{marshaling}
\alias{learner_unmarshal}
\alias{learner_marshal}
\alias{learner_marshaled}
\alias{marshal_model}
\alias{unmarshal_model}
\alias{marshaled_model}
\title{(Un)marshal a Learner}
\usage{
learner_unmarshal(learner)

learner_marshal(learner)

learner_marshaled(learner)

marshal_model(model, ...)

unmarshal_model(model, ...)

marshaled_model(model)
}
\arguments{
\item{learner}{\code{\link{Learner}}\cr
The learner.}
}
\description{
marshaling is the process of processing the model of a trained \code{\link{Learner}} so it an be successfully serialized and
deserialized. The naming is inspired by the \href{https://github.com/HenrikBengtsson/marshal}{marshal package} and we
plan to fully migrate to this package once it is on CRAN.
The supported implementation until then should therfore be considered as a temporary solution and is likely
to change in the future.

The central functions (and the only methods that are used by \code{mlr3} internally) are:
\itemize{
\item the S3 generic \code{marshal_model(model, ...)}.
Which takes in a model and returns it in marshaled form.
The marshaled object should be a list with named elements \code{marshaled} and \code{packages}, where the former contains
the actual marshaled object, and the latter the packages required to unmarshal it.
This list should have as classes the classes of the original object with the suffix \code{"_marshaled"} added and the
root class should be set to \code{"marshaled"}.
\item the S3 generic \code{unmarshal_model(model, ...)}.
Which takes in the marshaled model and returns it in unmarshaled form.
The generic takes care that the packages specified during \code{"marshal"} are loaded, and errs if they are not.
The returned object must not inherit from class \code{"marshaled"}.
\item the function \code{marshaled_model(model)}, which returns \code{TRUE} if the model inherits from class \code{"marshaled"}
and \code{FALSE} otherwise.
}

In order to implement marshaling for a Learner, you only need to overload the \code{marshal_model} and \code{unmarshal_model}
methods and tag the learner with the \code{"marshal"} property accordingly.

To make marshaling accessible in an R6-manner, you should also add the public methods \verb{$marshal()}, \verb{$unmarshal()}
and the active binding \verb{$marshaled}.
To make this as convenient as possible, the functions \code{learner_marshal(learner)}, \code{learner_unmarshal(learner)}
and \code{learner_marshaled(learner)} are provided and can be called from within the public methods.
All three functions throw an error if the learner is not trained and otherwise call
\code{marshal_model()}, \code{unmarshal_model()} or \code{marshaled_model()} on the learner's model.

You can verify whether you have correctly implemented marshaling by using the internal test helper
\code{expect_marshalable_learner()}. This is also run by \code{expect_learner()} if a task is provided.

For a concrete example on how to implement marshaling, see \code{\link{LearnerClassifLily}}.
}
\keyword{internal}

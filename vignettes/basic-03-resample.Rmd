---
title: "Introduction to Resampling"
author: "Michel Lang"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Resampling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(mlr3)
knitr::opts_knit$set(
  datatable.print.keys = FALSE,
  datatable.print.class = TRUE
)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(123)
```

This introduction is about resampling.

## Objects

Again, we consider the iris task and a simple classification tree here.

```{r}
library(mlr3)
task = mlr_tasks$get("iris")
learner = mlr_learners$get("classif.rpart")
```

Additionally, we need to define **how** we want to resample. `mlr3` comes with the following resampling strategies implemented:

```{r}
mlr_resamplings$keys()
```
The experiment conducted in the introduction on train/predict/score is equivalent to a simple "holdout", so let's consider this one first.

```{r}
resampling = mlr_resamplings$get("holdout")
print(resampling)
print(resampling$param_vals)
```
To change the ratio to $0.8$, we simply overwrite the slot:

```{r}
resampling$param_vals = list(ratio = 0.8)
```

## Resampling

Now, we can pass all created objects to the `resample()` function to get an object of class `ResampleResult`:

```{r}
rr = resample(task, learner, resampling)
print(rr)
```

Before we go into more detail, lets change the resampling to a 3-fold cross-validation to better illustrate what operations are possible with a resampling result.

```{r}
resampling = mlr_resamplings$get("cv")
resampling$param_vals = list(folds = 3)
rr = resample(task, learner, resampling)
print(rr)
```

We can do different things with resampling results, e.g.:

* Extract the performance for the individual resampling iterations:

```{r}
rr$performance("mmce")
```

* Extract and inspect the now instantiated resampling:

```{r}
rr$resampling
rr$resampling$iters
rr$resampling$test_set(1)
rr$resampling$test_set(2)
rr$resampling$test_set(3)
```

* Retrieve the experiment of a specific iteration and inspect it:

```{r}
e = rr$experiment(iter = 1)
e$model
```

## Manual Instantiation

If you want to compare multiple learners, you should use the same resampling per task to reduce the variance of the performance estimation.
Until now, we have just passed a resampling strategy to `resample()`, without specifying the actual splits into training and test.
Here, we manually instantiate the resampling:

```{r}
resampling = mlr_resamplings$get("cv")
resampling$param_vals = list(folds = 3)
resampling$instantiate(task)
resampling$iters
resampling$train_set(1)
```
If we now pass this instantiated object to resample, the pre-calculated training and test splits will be used for both learners:

```{r}
learner1 = mlr_learners$get("classif.rpart") # simple classification tree
learner2 = mlr_learners$get("classif.featureless") # featureless learner, prediction majority class
rr1 = resample(task, learner1, resampling)
rr2 = resample(task, learner2, resampling)

setequal(rr1$experiment(1)$train_set, rr2$experiment(1)$train_set)
```
We can also combine the created result objects into a `BenchmarkResult` (see below for an introduction to simple benchmarking):

```{r}
bmr = rr1$combine(rr2)
bmr$aggregated
```

## Custom Resampling

Sometimes it is necessary to perform resampling with custom splits, e.g. to reproduce a study.
For this purpose, splits can be manually set for `ResamplingCustom`:

```{r}
resampling = mlr_resamplings$get("custom")
resampling$instantiate(task,
  list(c(1:10, 51:60, 101:110)),
  list(c(11:20, 61:70, 111:120))
)
resampling$iters
resampling$train_set(1)
resampling$test_set(1)
```


## Benchmarking

As comparing the performance of multiple learners on multiple tasks is a frequent task, `mlr3` offers the `benchmark()` function for convenience.
Internally, the resampling strategies are automatically instantiated for you, so that each learner sees the same split of the data.

```{r}
# get some example tasks
tasks = mlr_tasks$mget(c("pima", "sonar", "spam"))

# get a featureless learner and a classification tree
learners = mlr_learners$mget(c("classif.featureless", "classif.rpart"))

# let the learners predict probabilities instead of class labels (required for AUC measure)
learners$classif.featureless$predict_type = "prob"
learners$classif.rpart$predict_type = "prob"

# compare via 10-fold cross validation
resamplings = mlr_resamplings$mget("cv")

# measure accuracy (acc) and area under the curve (AUC)
measures = mlr_measures$mget(c("acc", "auc"))

# create a BenchmarkResult object
bmr = benchmark(tasks, learners, resamplings, measures)
```

Usually you want to look at the results aggregated over resampling iterations:
```{r}
bmr$aggregated
```
We can aggregate it further, i.e. if we are interested which learner performed best over all tasks:
```{r}
bmr$aggregated[, list(acc = mean(acc), auc = mean(auc)), by = "learner_id"]
```
Unsurprisingly, the classification tree outperformed the featureless learner.

As a `BenchmarkResult` is basically a collection of multiple `ResampleResult`, we can extract specific `ResampleResult` using the stored hashes:
```{r}
tab = bmr$aggregated[task_id == "spam" & learner_id == "classif.rpart"]
print(tab)

rr = bmr$resample_result(tab$hash)
```
We can now investigate this resampling and even single experiments using the previously introduced API:
```{r}
rr$aggregated

# get the iteration with worst AUC
worst = as.data.table(rr)[which.min(auc), c("iteration", "auc")]
print(worst)

# get the corresponding experiment
e = rr$experiment(worst$iteration)

# get the model and plot it
library(rpart)
plot(e$model)
text(e$model)
```

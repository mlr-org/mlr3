---
title: "Handling model errors"
author: "Michel Lang"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Handling model errors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(mlr3)
knitr::opts_knit$set(
  datatable.print.keys = FALSE,
  datatable.print.class = TRUE
)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
future::plan("sequential")
set.seed(123)

### https://stackoverflow.com/questions/23442249/get-traceback-from-knitr-on-error
saveTraceback <- local({
  savedTraceback <- NULL
  saver <- function(e) {
    calls <- sys.calls()
    deparsed <- lapply(calls, deparse)
    deparsed <- deparsed[-length(deparsed)+0:1] # leave off last 2
    lastjunk <- max(grep("withCallingHandlers", deparsed))
    deparsed <- deparsed[-seq_len(lastjunk)]
    savedTraceback <<- deparsed
  }
  function(expr)
    withCallingHandlers(expr, error = saver)
})

traceback <- function() {
  base::traceback(environment(saveTraceback)$savedTraceback)
}
```

This vignettes demonstrates how to deal with learners which raise exceptions during train or predict.

# Setup

First, we need a simple learning task and a learner which raises exceptions.
For this purpose, `mlr3` ships with the learner `classif.crashtest`:
```{r}
task = mlr_tasks$get("spam")
learner = mlr_learners$get("classif.crashtest")
print(learner)
print(learner$param_set)
```
The hyperparameters let us control (a) whether it should crash during train or predict, and (b) if the learner should crash with an error or segfault (which tears down the complete R session).


# No Error Handling

In the defaults, `mlr3` does not handle model errors specially.
Thus, the exception raised by the crashtest learner can stops the execution and can be tracebacked:

```{r, error=TRUE, echo = -3}
e = Experiment$new(task, learner)
e$train()
safeTraceback(e$train())
traceback()
```
The traceback might be obfuscated by the parallelization framework, depending on your configuration and installation.
To get a better traceback, we turn the parallelization completely off:
```{r, error = TRUE, echo = -3}
ctrl = mlr_control(use_future = FALSE)
e$train(ctrl = ctrl)
safeTraceback(e$train(ctrl = ctrl))
traceback()
```

During parallelization, error messages (as well as normal output or warnings) are often not properly forwarded to the master R session.
To properly debug, the learner execution can be encapsulated, so its output is logged to the experiment.
To capture the output, the excellent evaluate package is used:
```{r}
ctrl = mlr_control(use_evaluate = TRUE)
e$train(ctrl = ctrl)
e$has_errors
e$logs$train
```
Note that, although no exception has been raised, it is impossible to perform the predict step without a model.

# Fallback Learners

Each learner can have a fallback learner, which is used if either the train or predict step fail.
Here, we simply fallback to the predictions of a featureless learner (predicting majority class):

```{r}
task = mlr_tasks$get("spam")
learner = mlr_learners$get("classif.crashtest")
learner$fallback = mlr_learners$get("classif.featureless")
ctrl = mlr_control(use_evaluate = TRUE)

e = Experiment$new(task = task, learner = learner)
e$train(ctrl = ctrl)
e$predict(ctrl = ctrl)
e$score(ctrl = ctrl)
e$prediction
e$performance
e$logs
```

Note that the logs and timings are tracked for the original learner, not the fallback learner:
